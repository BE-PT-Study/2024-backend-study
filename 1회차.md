## Synchronized
정의
- Java에서 synchronized 키워드는 메서드나 블록에 대한 동시 접근을 제한하여 스레드 안전성을 보장하는 방법입니다. synchronized 블록은 객체에 대한 락을 획득하고, 블록의 실행이 끝날 때 락을 해제합니다.

장점
- 간단하고 이해하기 쉽다: 사용법이 간단하여 쉽게 동기화를 구현할 수 있습니다.
- 자동 락 관리: 락 획득과 해제가 자동으로 이루어져서, 데드락의 위험을 줄일 수 있습니다.

단점
- 성능 저하: 락으로 인해 발생하는 오버헤드가 성능 저하를 일으킬 수 있습니다.
- 스케일 제한: 하나의 락에 여러 스레드가 접근하려 할 때 병목 현상이 발생할 수 있습니다.

## Optimistic Lock
정의
- 낙관적 락은 데이터베이스 또는 어떤 데이터 저장소에서 데이터를 변경하거나 읽을 때 충돌이 일어나지 않을 것이라고 가정하는 방법입니다. 주로 데이터 버전 관리를 통해 구현됩니다.

장점
- 높은 동시성: 충돌이 드물게 발생하는 환경에서 높은 성능을 제공합니다.
- 락 오버헤드 없음: 데이터를 락으로 보호하지 않으므로, 락으로 인한 지연이 없습니다.

단점
- 충돌 관리: 충돌이 발생하면 롤백 또는 재시도가 필요할 수 있습니다.
- 복잡한 구현: 버전 관리 사용하여 구현해야 하므로 테이블에 관련 컬럼을 추가해야합니다.

## Pessimistic Lock
정의
- 비관적 락은 충돌이 빈번히 발생할 것으로 예상되는 환경에서 데이터를 접근하기 전에 락을 획득하는 방법입니다. 데이터베이스 레벨에서 주로 지원합니다.

장점
- 충돌 방지: 데이터를 미리 락으로 보호하기 때문에 충돌을 사전에 방지할 수 있습니다.
- 예측 가능한 성능: 충돌 처리에 대한 부담이 없으므로 성능 예측이 용이합니다.

단점
- 낮은 동시성: 락으로 인해 동시에 많은 스레드가 접근하는 것이 제한됩니다.
- 데드락 위험: 잘못된 락 사용 패턴은 데드락을 유발할 수 있습니다.

## Lettuce Lock
정의
- Lettuce는 Redis 클라이언트 라이브러리로, Redis를 사용하여 분산 락을 구현할 수 있습니다. Lettuce Lock은 Redis의 명령을 활용하여 네트워크 분산 환경에서 락을 관리합니다.

장점
- 높은 확장성: Redis의 성능을 활용하여 높은 확장성과 성능을 제공합니다.
- 분산 시스템에 적합: 다수의 애플리케이션 인스턴스 간에 안정적인 락 관리를 지원합니다.

단점
- 외부 시스템 의존성: Redis 설치 및 유지 관리가 필요합니다.
- 네트워크 지연: 네트워크 지연에 의해 락 획득 시간이 영향을 받을 수 있습니다.

## Redisson Lock
정의
- Redisson은 Java를 위한 Redis 클라이언트 중 하나로, Redis를 이용한 분산 락 기능을 제공합니다. Redisson Lock은 Redis의 기능을 활용하여 안정적으로 분산 락을 구현합니다.

장점
- 고가용성: Redis의 클러스터링과 복제를 통해 높은 가용성을 제공합니다.
- 자동 잠금 해제: 클라이언트가 실패해도 락이 자동으로 만료되어 시스템이 락에 묶이지 않습니다.

단점
- 복잡성: Redis 설정과 클라이언트 구성이 필요하여 초기 설정이 복잡할 수 있습니다.
- 자원 사용: Redis 서버 자원을 사용하므로, 대규모 트래픽에서 리소스 관리가 중요합니다.